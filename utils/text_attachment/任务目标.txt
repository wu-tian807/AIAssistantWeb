明白了，这是一个非常有趣的递归式文本处理架构。让我帮您梳理一下整体结构：

1. **整体架构设计**：
```
TextProcessor
├── 初始决策层
│   ├── 文件大小检查
│   └── 处理策略选择
├── 文本获取层
│   ├── 完整读取（小文件）
│   └── 分块读取（大文件）
└── 分析处理层
    ├── 关键词匹配处理器
    ├── 语义搜索处理器
    └── 行号处理器
```

2. **处理流程**：
```mermaid
graph TD
    A[用户请求] --> B{文件大小判断}
    B -->|小于阈值| C[完整读取]
    B -->|大于阈值| D[模型决策]
    D --> E{策略选择}
    E -->|关键词| F[关键词匹配]
    E -->|语义| G[模糊搜索]
    E -->|行号| H[行处理]
    F --> I[结果分析]
    G --> I
    H --> I
    I -->|需要继续| D
    I -->|完成| J[返回结果]
```

3. **核心组件**：

```python
class TextProcessingStrategy:
    """文本处理策略基类"""
    def process(self, file_id: str, params: dict) -> dict:
        pass

class KeywordStrategy(TextProcessingStrategy):
    """关键词匹配策略"""
    def process(self, file_id: str, keywords: list) -> dict:
        # 返回匹配结果和上下文
        pass

class SemanticStrategy(TextProcessingStrategy):
    """语义搜索策略"""
    def process(self, file_id: str, description: str) -> dict:
        # 返回相关段落和相似度
        pass

class LineStrategy(TextProcessingStrategy):
    """行处理策略"""
    def process(self, file_id: str, line_numbers: list) -> dict:
        # 返回指定行及其上下文
        pass

class TextProcessor:
    """文本处理器"""
    def __init__(self, size_threshold: int = 10000):
        self.size_threshold = size_threshold
        self.strategies = {
            'keyword': KeywordStrategy(),
            'semantic': SemanticStrategy(),
            'line': LineStrategy()
        }

    async def process_request(self, file_id: str, user_query: str) -> dict:
        # 1. 检查文件大小
        file_size = await self.get_file_size(file_id)
        
        if file_size < self.size_threshold:
            # 小文件直接返回全部内容
            return await self.read_full_content(file_id)
            
        # 2. 交给模型决策
        return await self.model_decision_loop(file_id, user_query)

    async def model_decision_loop(self, file_id: str, user_query: str) -> dict:
        while True:
            # 1. 获取模型决策
            decision = await self.get_model_decision(user_query)
            
            # 2. 执行相应策略
            result = await self.execute_strategy(
                file_id, 
                decision.strategy, 
                decision.params
            )
            
            # 3. 让模型分析结果
            next_action = await self.analyze_result(result)
            
            if next_action.should_stop:
                return result
                
            # 更新查询继续循环
            user_query = next_action.next_query
```

4. **关键设计点**：

- **递归控制**：模型可以根据结果决定是否需要继续处理
- **策略模式**：不同的处理方式封装在独立的策略类中
- **异步处理**：使用异步操作处理文件IO
- **结果缓存**：可以缓存处理结果避免重复操作
- **上下文保持**：保持处理过程中的上下文信息

5. **与现有系统的集成**：

需要修改的部分：
1. `message_processor.py` 需要增加文本处理的专门路由
2. 添加新的函数调用接口供模型使用
3. 在 `text_handler.py` 中实现各种文本处理策略
4. 添加文本处理的结果缓存机制

您觉得这个架构设计如何？我们可以先确定整体架构，然后逐步实现各个组件。
