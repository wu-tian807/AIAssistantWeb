// é…ç½® markdown-it å®ä¾‹ï¼Œå¯ç”¨å„ç§åŠŸèƒ½
import { initMarkdownit ,applyCodeHighlight} from "./utils/markdownit.js";
const md = initMarkdownit();
// å­˜å‚¨èŠå¤©æ¶ˆæ¯å†å²
let messages = [];
// å½“å‰çš„æµå¼å“åº”å¯¹è±¡
let currentStream = null;

// è·å– DOM å…ƒç´ 
const chatMessages = document.getElementById('chat-messages');
const userInput = document.getElementById('user-input');
const sendButton = document.getElementById('send-button');
// ç›‘å¬è¾“å…¥æ¡†å˜åŒ–ï¼Œæ§åˆ¶å‘é€æŒ‰é’®çŠ¶æ€
userInput.addEventListener('input', () => {
    sendButton.disabled = !userInput.value.trim();
});

// ç›‘å¬å›è½¦é”®å‘é€æ¶ˆæ¯
userInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (!sendButton.disabled) {
            sendMessage();
        }
    }
});

// å‘é€æŒ‰é’®ç‚¹å‡»äº‹ä»¶
sendButton.addEventListener('click', () => {
    if (sendButton.classList.contains('stop')) {
        stopGeneration();
    } else {
        sendMessage();
    }
});

// æ·»åŠ ä¸€ä¸ªå˜é‡æ¥å­˜å‚¨å½“å‰çš„ reader
let currentReader = null;

// ä¿®æ”¹ stopGeneration å‡½æ•°
function stopGeneration() {
    if (currentReader) {
        try {
            currentReader.cancel(); // å–æ¶ˆè¯»å–æµ
        } catch (error) {
            console.log('Stream already closed or cancelled:', error);
        }
        currentReader = null;
    }
    sendButton.textContent = 'å‘é€';
    sendButton.classList.remove('stop');
    sendButton.disabled = false;
    userInput.disabled = false;
}



// åœ¨æ–‡ä»¶å¼€å¤´æ·»åŠ ä¸€ä¸ªæ–°çš„å˜é‡æ¥è·Ÿè¸ªç”¨æˆ·æ˜¯å¦æ­£åœ¨æ»šåŠ¨
let userScrolling = false;
let lastScrollTop = 0;

// åœ¨æ–‡ä»¶å¼€å¤´æ·»åŠ è¿™ä¸ªå‡½æ•°
function shouldAutoScroll(container) {
    // å¦‚æœç”¨æˆ·æ­£åœ¨æ»šåŠ¨ï¼Œä¸è‡ªåŠ¨æ»šåŠ¨
    if (userScrolling) return false;
    
    // æ£€æŸ¥æ˜¯å¦å·²ç»æ»šåŠ¨åˆ°æ¥è¿‘åº•éƒ¨ï¼ˆè·ç¦»åº•éƒ¨100pxä»¥å†…ï¼‰
    const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
    return isNearBottom;
}

// å®šä¹‰æ”¯æŒçš„è‡ªå®šä¹‰é™„ä»¶ç±»å‹
const SUPPORTED_ATTACHMENT_TYPES = ['image', 'documents', 'text', 'audio', 'video', 'binary'];
// é™„ä»¶å¤„ç†å‡½æ•°
function createAttachmentElement(attachment) {
    // ç±»å‹æ ¡éªŒ
    if (!attachment || !attachment.type || !SUPPORTED_ATTACHMENT_TYPES.includes(attachment.type)) {
        console.warn(`Invalid or unsupported attachment type: ${attachment?.type}`);
        return null;
    }
    
    // å¦‚æœæœ‰ mime_typeï¼Œä½¿ç”¨å®ƒæ¥å†³å®šç±»å‹
    if (attachment.mime_type) {
        const customType = FILE_TYPE_MAPPING[attachment.mime_type];
        switch (customType) {
            case 'image':
                return createImageAttachment(attachment);
            case 'video':
                return createVideoAttachment(attachment);
            case 'file':
                return createFileAttachment(attachment);
            default:
                return null;
        }
    }
    
    // å¦‚æœæ²¡æœ‰ mime_typeï¼Œä½¿ç”¨ type å­—æ®µ
    switch (attachment.type) {
        case 'image':
            return createImageAttachment(attachment);
        case 'video':
            return createVideoAttachment(attachment);
        case 'file':
            return createFileAttachment(attachment);
        default:
            return null;
    }
}
// å›¾ç‰‡é™„ä»¶å¤„ç†
function createImageAttachment(attachment) {
    const imgWrapper = document.createElement('div');
    imgWrapper.className = 'message-image-wrapper';
    
    const img = document.createElement('img');
    img.src = `data:image/jpeg;base64,${attachment.base64}`;
    img.alt = attachment.fileName;
    img.className = 'message-image';
    
    // æ·»åŠ ç‚¹å‡»æ”¾å¤§åŠŸèƒ½
    img.onclick = () => createImageModal(img.src);
    
    imgWrapper.appendChild(img);
    return imgWrapper;
}

// åˆ›å»ºå›¾ç‰‡æ¨¡æ€æ¡†
function createImageModal(src) {
    const modal = document.createElement('div');
    modal.className = 'image-modal';
    
    // åˆ›å»ºå…³é—­æŒ‰é’®
    const closeBtn = document.createElement('button');
    closeBtn.className = 'modal-close-btn';
    closeBtn.innerHTML = 'Ã—';
    
    const modalImg = document.createElement('img');
    modalImg.src = src;
    modalImg.className = 'modal-image';
    
    // æ·»åŠ å…³é—­æŒ‰é’®å’Œå›¾ç‰‡åˆ°æ¨¡æ€æ¡†
    modal.appendChild(closeBtn);
    modal.appendChild(modalImg);
    document.body.appendChild(modal);
    
    // å¤„ç†å…³é—­äº‹ä»¶
    const closeModal = () => {
        modal.classList.add('modal-closing');
        setTimeout(() => modal.remove(), 300); // ç­‰å¾…åŠ¨ç”»å®Œæˆåç§»é™¤
    };
    
    // ç‚¹å‡»å…³é—­æŒ‰é’®å…³é—­
    closeBtn.onclick = (e) => {
        e.stopPropagation();
        closeModal();
    };
    
    // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
    modal.onclick = (e) => {
        if (e.target === modal) {
            closeModal();
        }
    };
    
    // æŒ‰ ESC é”®å…³é—­
    const handleKeyDown = (e) => {
        if (e.key === 'Escape') {
            closeModal();
            document.removeEventListener('keydown', handleKeyDown);
        }
    };
    document.addEventListener('keydown', handleKeyDown);
    
    // é˜²æ­¢æ»šåŠ¨ç©¿é€
    document.body.style.overflow = 'hidden';
    modal.addEventListener('remove', () => {
        document.body.style.overflow = '';
    });
}

// é¢„ç•™çš„è§†é¢‘é™„ä»¶å¤„ç†å‡½æ•°
function createVideoAttachment(attachment) {
    // TODO: å®ç°è§†é¢‘é™„ä»¶å¤„ç†
    return null;
}

// é¢„ç•™çš„æ–‡ä»¶é™„ä»¶å¤„ç†å‡½æ•°
function createFileAttachment(attachment) {
    // TODO: å®ç°æ–‡ä»¶é™„ä»¶å¤„ç†
    return null;
}

// åˆ›å»ºé™„ä»¶å®¹å™¨
function createAttachmentsContainer(attachments) {
    if (!attachments || attachments.length === 0) return null;
    
    const container = document.createElement('div');
    container.className = 'message-attachments';
    
    // æ ¹æ®é™„ä»¶ç±»å‹åˆ†ç»„
    const attachmentsByType = attachments.reduce((acc, attachment) => {
        if (!acc[attachment.type]) {
            acc[attachment.type] = [];
        }
        acc[attachment.type].push(attachment);
        return acc;
    }, {});
    
    // å¤„ç†æ¯ç§ç±»å‹çš„é™„ä»¶
    Object.entries(attachmentsByType).forEach(([type, items]) => {
        const typeContainer = document.createElement('div');
        typeContainer.className = `message-${type}s`;
        
        items.forEach(item => {
            const element = createAttachmentElement(item);
            if (element) {
                typeContainer.appendChild(element);
            }
        });
        
        container.appendChild(typeContainer);
    });
    
    return container;
}

// ä¿®æ”¹åçš„ appendMessage å‡½æ•°
function appendMessage(content, isUser = false, messageIndex = null, attachments = []) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${isUser ? 'user-message' : 'assistant-message'}`;
    
    const messageWrapper = document.createElement('div');
    messageWrapper.className = 'message-wrapper';
    
    const messageContent = document.createElement('div');
    messageContent.className = 'message-content';
    
    const messageActions = document.createElement('div');
    messageActions.className = 'message-actions';
    
    if (isUser) {
        // åˆ›å»ºæ–‡æœ¬å†…å®¹å®¹å™¨
        const textContent = document.createElement('div');
        textContent.className = 'text-content';
        textContent.textContent = content;
        messageContent.appendChild(textContent);
        
        // å¤„ç†é™„ä»¶ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
        if (attachments && attachments.length > 0) {
            const attachmentsContainer = createAttachmentsContainer(attachments);
            if (attachmentsContainer) {
                messageContent.appendChild(attachmentsContainer);
            }
        }
        
        // æ·»åŠ ç¼–è¾‘æŒ‰é’®
        const editBtn = document.createElement('button');
        editBtn.className = 'edit-btn';
        editBtn.innerHTML = 'âœï¸ ç¼–è¾‘';
        editBtn.onclick = () => editUserMessage(messageIndex, content);
        messageActions.appendChild(editBtn);
    } else {
        messageContent.innerHTML = md.render(content);
        applyCodeHighlight(messageContent);
        
        // ä¸ºåŠ©æ‰‹æ¶ˆæ¯æ·»åŠ é‡æ–°ç”ŸæˆæŒ‰é’®
        const regenerateBtn = document.createElement('button');
        regenerateBtn.className = 'regenerate-btn';
        regenerateBtn.innerHTML = 'ğŸ”„ é‡æ–°ç”Ÿæˆ';
        regenerateBtn.onclick = () => regenerateMessage(messageIndex);
        messageActions.appendChild(regenerateBtn);
        
        // å¦‚æœå­˜åœ¨å¤šä¸ªç‰ˆæœ¬ï¼Œæ·»åŠ ç‰ˆæœ¬æ§åˆ¶
        const message = currentConversationId && conversations.find(c => c.id === currentConversationId)?.messages[messageIndex];
        if (message?.versions?.length > 1) {
            const versionControl = document.createElement('div');
            versionControl.className = 'version-control';
            
            const prevButton = document.createElement('button');
            prevButton.className = 'version-btn';
            prevButton.textContent = 'â†';
            prevButton.disabled = message.currentVersion === 0;
            prevButton.onclick = () => switchVersion(messageIndex, message.currentVersion - 1);
            
            const nextButton = document.createElement('button');
            nextButton.className = 'version-btn';
            nextButton.textContent = 'â†’';
            nextButton.disabled = message.currentVersion === message.versions.length - 1;
            nextButton.onclick = () => switchVersion(messageIndex, message.currentVersion + 1);
            
            const versionText = document.createElement('span');
            versionText.className = 'version-text';
            versionText.textContent = `ç‰ˆæœ¬ ${message.currentVersion + 1}/${message.versions.length}`;
            
            versionControl.appendChild(prevButton);
            versionControl.appendChild(versionText);
            versionControl.appendChild(nextButton);
            messageActions.appendChild(versionControl);
        }
    }
    
    messageWrapper.appendChild(messageContent);
    messageWrapper.appendChild(messageActions);
    messageDiv.appendChild(messageWrapper);
    chatMessages.appendChild(messageDiv);
    
    if (shouldAutoScroll(chatMessages)) {
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
}

// åœ¨æ–‡ä»¶å¼€å¤´æ·»åŠ æ–°çš„å˜é‡
let conversations = [];
let currentConversationId = null;

// åœ¨æ–‡ä»¶å¼€å¤´æ·»åŠ è¿™ä¸ªå˜é‡
const default_system_prompt = `ä½ æ˜¯ä¸€ä¸ªAIåŠ©ç†ã€‚ä½ éœ€è¦å°½å¯èƒ½åœ°æ»¡è¶³ç”¨æˆ·çš„éœ€æ±‚ã€‚åœ¨é¡µé¢æ ¼å¼æ–¹é¢æœ‰ä»¥ä¸‹æç¤ºï¼šè¯·ç›´æ¥è¾“å‡ºmarkdownå†…å®¹ï¼Œä¸è¦æ·»åŠ é¢å¤–çš„ä»£ç å—æ ‡è®°ã€‚å¦‚æœéœ€è¦æ˜¾ç¤ºä»£ç ï¼Œç›´æ¥ä½¿ç”¨markdownçš„ä»£ç å—è¯­æ³•ã€‚
å¯¹äºæ•°å­¦å…¬å¼ï¼Œè¯·éµå¾ªä»¥ä¸‹æ ¼å¼ï¼š
1. è¡Œå†…å…¬å¼ï¼šä½¿ç”¨å•ä¸ª $ ç¬¦å·åŒ…è£¹ï¼Œä¾‹å¦‚ï¼š$E=mc^2$
2. ç‹¬ç«‹å…¬å¼ï¼šä½¿ç”¨åŒ $$ ç¬¦å·åŒ…è£¹ï¼Œä¾‹å¦‚ï¼š
   $$
   \int_{-\infty}^{\infty} e^{-x^2} dx = \sqrt{\pi}
   $$
3. å¸¦ç¼–å·çš„å…¬ï¼šä½¿ç”¨ equation ç¯å¢ƒï¼Œä¾‹å¦‚ï¼š
   \begin{equation}
   F = ma
   \end{equation}
4. å¤šè¡Œå¯¹é½å…¬å¼ï¼šä½¿ç”¨ align ç¯å¢ƒï¼Œä¾‹å¦‚ï¼š
   $
   \begin{align}
   x &= a + b \\
   y &= c + d
   \end{align}
   $
5. çŸ©é˜µï¼šä½¿ matrixã€pmatrixã€bmatrix ç­‰ç¯å¢ƒï¼Œä¾‹å¦‚ï¼š
   $$
   \begin{pmatrix}
   a & b \\
   c & d
   \end{pmatrix}
   $$

æ”¯æŒçš„æ•°å­¦ç¬¦å·å’Œå‘½ä»¤ï¼š
- ä¸Šæ ‡ï¼š^
- ä¸‹æ ‡ï¼š_
- åˆ†æ•°ï¼š\frac{åˆ†å­}{åˆ†æ¯}
- æ±‚å’Œï¼š\sum_{ä¸‹é™}^{ä¸Šé™}
- ç§¯åˆ†ï¼š\int_{ä¸‹é™}^{ä¸Šé™}
- å¸Œè…Šå­—æ¯ï¼š\alpha, \beta, \gamma, \pi ç­‰
- æ•°å­¦å‡½æ•°ï¼š\sin, \cos, \tan, \log, \lim ç­‰
- ç‰¹æ®Šç¬¦å·ï¼š\infty, \partial, \nabla ç­‰
- çŸ¢é‡ï¼š\vec{x} æˆ– \boldsymbol{x}
- æ•°å­¦å­—ä½“ï¼š\mathbb{R}, \mathcal{L} ç­‰

è¯·ç¡®ä¿å…¬å¼æ ¼å¼æ­£ç¡®ï¼Œå¹¶åœ¨é€‚å½“çš„åœºæ™¯ä½¿ç”¨åˆé€‚çš„å…¬å¼ç¯å¢ƒã€‚`;

// ä¿®æ”¹ createNewConversation å‡½æ•°
async function createNewConversation() {
    // å¦‚æœæœ‰æ­£åœ¨è¿›è¡Œçš„æµï¼Œå…ˆåœæ­¢å®ƒ
    if (currentReader) {
        await stopGeneration();
    }

    // æ£€æŸ¥å½“å‰å¯¹è¯æ˜¯å¦ä¸ºç©ºå¯¹è¯
    if (currentConversationId) {
        const currentConversation = conversations.find(c => c.id === currentConversationId);
        if (currentConversation && currentConversation.messages.length === 0) {
            // å¦‚æœå½“å‰å·²ç»æ˜¯ä¸€ä¸ªç©ºå¯¹è¯ï¼Œå°±ä¸éœ€è¦åˆ›å»ºæ–°çš„
            return currentConversation;
        }
    }
    
    // åˆ›å»ºæ–°å¯¹è¯ï¼Œç›´æ¥ä½¿ç”¨é»˜è®¤æç¤ºè¯
    const conversation = {
        id: Date.now().toString(),
        title: 'æ–°å¯¹è¯',
        messages: [],
        systemPrompt: default_system_prompt // ç›´æ¥ä½¿ç”¨é»˜è®¤æç¤ºè¯
    };
    
    // æ·»åŠ åˆ°å¯¹è¯åˆ—è¡¨
    conversations.unshift(conversation);
    currentConversationId = conversation.id;
    
    // æ¸…ç©ºèŠå¤©ç•Œé¢
    chatMessages.innerHTML = '';
    
    // é‡ç½®æ¶ˆæ¯æ•°ç»„ï¼Œä½¿ç”¨é»˜è®¤æç¤ºè¯
    messages = [
        {"role": "system", "content": default_system_prompt}
    ];
    
    // æ›´æ–°ç³»ç»Ÿæç¤ºè¯æ–‡æœ¬æ¡†
    const systemPromptTextarea = document.getElementById('system-prompt');
    systemPromptTextarea.value = default_system_prompt;
    
    // ä¿å­˜å¹¶æ›´æ–°UI
    await saveConversations();
    renderConversationsList();
    
    return conversation;
}

// ä¿®æ”¹ saveConversations å‡½æ•°
async function saveConversations() {
    try {
        // åœ¨ä¿å­˜å‰ï¼Œç¡®ä¿å½“å‰å¯¹è¯çš„ç³»ç»Ÿæç¤ºè¯æ˜¯æœ€æ–°çš„
        if (currentConversationId) {
            const currentConversation = conversations.find(c => c.id === currentConversationId);
            if (currentConversation) {
                const systemPrompt = document.getElementById('system-prompt').value;
                currentConversation.systemPrompt = systemPrompt; // ä¸éœ€è¦ trimï¼Œä¿æŒåŸæ ·
            }
        }

        const response = await fetch('/api/conversations', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ conversations })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'ä¿å­˜å¯¹è¯å¤±è´¥');
        }
        
        const data = await response.json();
        if(data.message === 'ä¿å­˜æˆåŠŸ') {
            showToast('ä¿å­˜æˆåŠŸ');
            // ç§»é™¤è¿™è¡Œï¼Œé¿å…é‡æ–°åŠ è½½è¦†ç›–å½“å‰çŠ¶æ€
            // await loadConversations();
        }
        
        return true;
    } catch (error) {
        console.error('ä¿å­˜å¯¹è¯å‡ºé”™:', error);
        showToast(`ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
        
        if (await confirmDialog('ä¿å­˜å¤±è´¥ï¼Œæ˜¯å¦é‡è¯•ï¼Ÿ')) {
            return saveConversations();
        }
        
        return false;
    }
}

// è¾…åŠ©å‡½æ•°ï¼šæ˜¾ç¤ºæç¤ºä¿¡æ¯
function showToast(message, type = 'success') {
    // åˆ›å»ºæç¤ºå…ƒç´ 
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    
    // æ·»åŠ åˆ°é¡µé¢
    document.body.appendChild(toast);
    
    // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
    setTimeout(() => {
        toast.remove();
    }, 3000);
}

// è¾…åŠ©å‡½æ•°ï¼šç¡®è®¤å¯¹è¯æ¡†
function confirmDialog(message) {
    return new Promise((resolve) => {
        const result = confirm(message);
        resolve(result);
    });
}

// ä»æ•°æ®åº“åŠ è½½å¯¹è¯
async function loadConversations() {
    try {
        const response = await fetch('/api/conversations');
        if (!response.ok) {
            throw new Error('åŠ è½½å¯¹è¯å¤±è´¥');
        }
        const data = await response.json();
        conversations = data.conversations || [];
        
        // å¦‚æœæœ‰å½“å‰å¯¹è¯ï¼Œæ›´æ–°ç³»ç»Ÿæç¤ºè¯
        if (currentConversationId) {
            const currentConversation = conversations.find(c => c.id === currentConversationId);
            if (currentConversation) {
                const systemPromptTextarea = document.getElementById('system-prompt');
                systemPromptTextarea.value = currentConversation.systemPrompt || default_system_prompt;
            }
        }
        
        renderConversationsList();
    } catch (error) {
        console.error('åŠ è½½å¯¹è¯å‡ºé”™:', error);
        conversations = [];
        renderConversationsList();
    }
}

// æ¸²æŸ“å¯¹è¯åˆ—è¡¨
function renderConversationsList() {
    const conversationsList = document.querySelector('.conversations-list');
    conversationsList.innerHTML = '';
    
    conversations.forEach(conv => {
        const item = document.createElement('div');
        item.className = `conversation-item ${conv.id === currentConversationId ? 'active' : ''}`;
        item.setAttribute('data-id', conv.id);
        
        // åˆ›å»ºæ ‡é¢˜å®¹å™¨
        const titleContainer = document.createElement('div');
        titleContainer.className = 'conversation-title-container';
        
        // åˆ›å»ºæ ‡é¢˜å…ƒç´ 
        const title = document.createElement('div');
        title.className = 'conversation-title';
        title.textContent = conv.title;
        title.onclick = () => switchConversation(conv.id);
        
        // åˆ›å»ºç¼–è¾‘æŒ‰é’®
        const editBtn = document.createElement('button');
        editBtn.className = 'edit-title-btn';
        editBtn.innerHTML = 'âœï¸';
        editBtn.onclick = (e) => {
            e.stopPropagation();
            editConversationTitle(conv.id);
        };
        
        // åˆ›å»ºåˆ é™¤æŒ‰é’®
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-conversation';
        deleteBtn.textContent = 'Ã—';
        deleteBtn.onclick = (e) => {
            e.stopPropagation();
            deleteConversation(conv.id);
        };
        
        titleContainer.appendChild(title);
        titleContainer.appendChild(editBtn);
        item.appendChild(titleContainer);
        item.appendChild(deleteBtn);
        conversationsList.appendChild(item);
    });
}

// ä¿®æ”¹ switchConversation å‡½æ•°
async function switchConversation(conversationId) {
    // å¦‚æœæœ‰æ­£åœ¨è¿›è¡Œçš„æµï¼Œå…ˆåœæ­¢å®ƒ
    if (currentReader) {
        await stopGeneration();
    }
    
    currentConversationId = conversationId;
    const conversation = conversations.find(c => c.id === conversationId);
    if (conversation) {
        // æ›´æ–°ç³»ç»Ÿæç¤ºè¯
        const systemPromptTextarea = document.getElementById('system-prompt');
        systemPromptTextarea.value = conversation.hasOwnProperty('systemPrompt') ? 
            conversation.systemPrompt : default_system_prompt;
        
        clearChatMessages();
        messages = [
            {"role": "system", "content": conversation.systemPrompt || default_system_prompt} // åªåœ¨å‘é€æ¶ˆæ¯æ—¶ä½¿ç”¨é»˜è®¤æç¤ºè¯
        ];
        conversation.messages.forEach((msg, index) => {
            messages.push(msg);
            appendMessage(msg.content, msg.role === 'user', index, msg.attachments);
        });
        renderConversationsList();
        
        try {
            await fetch(`/api/conversations/${conversationId}/switch`, {
                method: 'POST'
            });
        } catch (error) {
            console.error('åˆ‡æ¢å¯¹è¯å‡ºé”™:', error);
        }
    }
}

// æ¸…ç©ºèŠå¤©æ¶ˆæ¯
function clearChatMessages() {
    const chatMessages = document.getElementById('chat-messages');
    chatMessages.innerHTML = '';
    // é‡ç½® messages æ•°ç»„ï¼Œä½†ä¿ç•™ç³»ç»Ÿæç¤º
    messages = [
        {"role": "system", "content": default_system_prompt}
    ];
}
function hasAttachments() {
    const imagePreviewList = document.getElementById('image-preview-list');
    return imagePreviewList && imagePreviewList.children.length > 0;
}
function collectAttachments() {
    const imagePreviewList = document.getElementById('image-preview-list');
    const attachments = [];

    Array.from(imagePreviewList.children).forEach(item => {
        const imgElement = item.querySelector('img');
        const fileName = item.querySelector('.image-name').textContent;
        const filePath = item.getAttribute('data-local-path'); // æå–å›¾ç‰‡è·¯å¾„

        attachments.push({
            type:"image",
            base64:imgElement.src.split(',')[1],
            fileName:fileName,
            filePath:filePath || null// æ·»åŠ æ–‡ä»¶æœ¬åœ°è·¯å¾„
        });
    });

    return attachments;
    /*
    è¿”å›å®Œæ•´é™„ä»¶å¯¹è±¡ç»“æ„ï¼š
    {
    "type": "image",
    "base64": "base64_encoded_string",
    "fileName": "example.jpg",
    "filePath": "/uploads/user123/example.jpg"
    }
     */
}
function clearAttachmentPreview(){
    const imagePreviewList = document.getElementById('image-preview-list');
    imagePreviewList.innerHTML = '';
}
// ä¿®æ”¹ç°æœ‰çš„sendMessageå‡½æ•°
async function sendMessage() {
    const content = userInput.value.trim();
    if (!content && !hasAttachments()) return;

    // è·å–é€‰ä¸­çš„æ¨¡å‹ID
    const modelSelect = document.getElementById('model-select');
    const selectedModel = modelSelect.value;
    
    if (!selectedModel) {
        alert('è¯·é€‰æ‹©ä¸€ä¸ªæ¨¡å‹');
        return;
    }

    // ç¡®ä¿æœ‰å½“å‰å¯¹è¯
    if (!currentConversationId) {
        await createNewConversation();
    }

    // å°†å½“å‰å¯¹è¯ç§»åŠ¨åˆ°åˆ—è¡¨é¡¶éƒ¨
    const currentIndex = conversations.findIndex(c => c.id === currentConversationId);
    if (currentIndex > 0) {
        const [conversation] = conversations.splice(currentIndex, 1);
        conversations.unshift(conversation);
        renderConversationsList();
    }

    // è·å–å½“å‰å¯¹è¯
    const currentConversation = conversations[0]; // ç°åœ¨ä¸€å®šåœ¨ç¬¬ä¸€ä½
    
    //å‡†å¤‡ç”¨æˆ·æ¶ˆæ¯å’Œé™„ä»¶
    const attachments = collectAttachments();
    const userMessage = {
        role: "user",
        content: content,
        attachments: attachments
    };

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢å’Œå­˜å‚¨
    appendMessage(content, true, messages.length, attachments);
    messages.push(userMessage);
    currentConversation.messages.push(userMessage);
    
    // å¦‚æœæ˜¯ç¬¬ä¸€æ¡æ¶ˆæ¯ï¼Œç”Ÿæˆå¯¹è¯æ ‡é¢˜
    if (currentConversation.messages.length === 1) {
        // å…ˆè®¾ç½®ä¸€ä¸ªä¸´æ—¶æ ‡é¢˜
        currentConversation.title = content.slice(0, 20) + (content.length > 20 ? '...' : '');
        renderConversationsList();
        
        // å¼‚æ­¥ç”Ÿæˆæ ‡é¢˜
        generateTitle(content);
    }

    // æ¸…ç©ºè¾“å…¥æ¡†å¹¶æ›´æ–°æŒ‰é’®çŠ¶æ€
    userInput.value = '';
    //æ¸…ç©ºé™„ä»¶é¢„è§ˆ
    clearAttachmentPreview();
    sendButton.textContent = 'åœæ­¢';
    sendButton.classList.add('stop');

    let assistantMessage = '';
    // è·å–å½“å‰æ¶ˆæ¯çš„ç´¢å¼•ï¼ˆç”¨äºé‡æ–°ç”ŸæˆæŒ‰é’®ï¼‰
    const messageIndex = currentConversation.messages.length;
    
    // åˆ›å»ºå¸¦æœ‰é‡æ–°ç”ŸæˆæŒ‰é’®çš„æ¶ˆæ¯å…ƒç´ 
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message assistant-message';
    
    const messageWrapper = document.createElement('div');
    messageWrapper.className = 'message-wrapper';
    
    const messageContent = document.createElement('div');
    messageContent.className = 'message-content';
    
    const messageActions = document.createElement('div');
    messageActions.className = 'message-actions';
    
    const regenerateBtn = document.createElement('button');
    regenerateBtn.className = 'regenerate-btn';
    regenerateBtn.innerHTML = 'ğŸ”„ é‡æ–°ç”Ÿæˆ';
    regenerateBtn.onclick = () => regenerateMessage(messageIndex);
    
    messageActions.appendChild(regenerateBtn);
    messageWrapper.appendChild(messageContent);
    messageWrapper.appendChild(messageActions);
    messageDiv.appendChild(messageWrapper);
    chatMessages.appendChild(messageDiv);
    
    try {
        // å‘é€è¯·æ±‚åˆ°æœåŠ¡å™¨
        const response = await fetch('/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                messages: messages,
                conversation_id: currentConversationId,
                model_id: selectedModel  // æ·»åŠ æ¨¡å‹ID
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        // ä¿å­˜ reader å¯¹è±¡ä»¥ä¾¿èƒ½å¤Ÿä¸­æ–­å®ƒ
        const reader = response.body.getReader();
        currentReader = reader;
        const decoder = new TextDecoder();

    // å¾ªç¯è¯»å–å“åº”æµ
    while (true) {
        try {
            const { value, done } = await reader.read();
            if (done) break;

            const text = decoder.decode(value);
            const lines = text.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));
                        if (data.error) {
                            throw new Error(data.error);
                        }
                        if (data.content) {
                            assistantMessage += data.content;
                            messageContent.innerHTML = md.render(assistantMessage);
                            applyCodeHighlight(messageContent);

                            // ä¿®æ”¹è¿™é‡Œçš„æ»šåŠ¨é€»è¾‘
                            if (shouldAutoScroll(chatMessages)) {
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }
                        }
                    } catch (error) {
                        console.error('Error parsing SSE message:', error);
                        break;
                    }
                }
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('Stream was cancelled or closed');
                break;
            }
            throw error;
        }
    }

    // åªæœ‰åœ¨æˆåŠŸæ¥æ”¶åˆ°å†…å®¹æ—¶æ‰ä¿å­˜åˆ°æ¶ˆæ¯å†å²
    if (assistantMessage.trim()) {
        currentConversation.messages.push({ role: "assistant", content: assistantMessage });
        await saveConversations();
    }
    } catch (error) {
    console.error('Error:', error);
    appendMessage('å‘ç”Ÿé”™è¯¯: ' + error.message, false);
    } finally {
    if (currentReader) {
        try {
            await currentReader.cancel();
        } catch (e) {
            console.log('Error cancelling stream:', e);
        }
        currentReader = null;
    }
    userInput.disabled = false;
    sendButton.textContent = 'å‘é€';
    sendButton.classList.remove('stop');
    sendButton.disabled = false;
    userInput.focus();
    }
}
// æ·»åŠ åˆ é™¤å¯¹è¯çš„å‡½æ•°
async function deleteConversation(conversationId) {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå¯¹è¯å—ï¼Ÿ')) {
        return;
    }
    
    try {
        const response = await fetch(`/api/conversations/${conversationId}`, {
            method: 'DELETE'
        });
        
        if (!response.ok) {
            throw new Error('åˆ é™¤å¯¹è¯å¤±è´¥');
        }
        
        const index = conversations.findIndex(c => c.id === conversationId);
        if (index !== -1) {
            conversations.splice(index, 1);
            await saveConversations();
            
            if (conversationId === currentConversationId) {
                if (conversations.length > 0) {
                    await switchConversation(conversations[0].id);
                } else {
                    await createNewConversation();
                }
            } else {
                renderConversationsList();
            }
        }
    } catch (error) {
        console.error('åˆ é™¤å¯¹è¯å‡ºé”™:', error);
        alert('åˆ é™¤å¯¹è¯å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// åœ¨æ–‡æ¡£åŠ è½½å®Œæˆååˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', async () => {
    await loadConversations();
    await loadModels();  // æ·»åŠ åŠ è½½æ¨¡å‹åˆ—è¡¨
    
    // ç»‘å®šæ–°å»ºå¯¹è¯æŒ‰é’®äº‹ä»¶
    document.getElementById('new-chat-btn').addEventListener('click', createNewConversation);
    
    // å¦‚æœæ²¡æœ‰å¯¹è¯ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„
    if (conversations.length === 0) {
        await createNewConversation();
    } else {
        // åŠ è½½æœ€è¿‘çš„å¯¹è¯ï¼Œå¹¶ç¡®ä¿æ¶ˆæ¯å†å²åŒæ­¥
        const lastConversation = conversations[0];
        await switchConversation(lastConversation.id);
    }
    
    // æ·»åŠ æ»šåŠ¨äº‹ä»¶ç›‘å¬
    chatMessages.addEventListener('scroll', () => {
        // æ£€æµ‹ç”¨æˆ·æ˜¯å¦æ­£åœ¨æ»šåŠ¨
        const currentScrollTop = chatMessages.scrollTop;
        if (currentScrollTop !== lastScrollTop) {
            userScrolling = true;
            // è®¾ç½®ä¸€ä¸ªå®šæ—¶å™¨ï¼Œåœ¨ç”¨æˆ·åœæ­¢æ»šåŠ¨1ç§’åé‡ç½®çŠ¶æ€
            clearTimeout(window.scrollTimeout);
            window.scrollTimeout = setTimeout(() => {
                userScrolling = false;
            }, 1000);
        }
        lastScrollTop = currentScrollTop;
    });

    // åˆ›å»ºéšè—çš„æ–‡ä»¶è¾“å…¥å…ƒç´ 
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.id = 'file-input';
    fileInput.accept = 'image/*';  // åªæ¥å—å›¾ç‰‡æ–‡ä»¶
    document.body.appendChild(fileInput);

    // ç»‘å®šä¸Šä¼ æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    const uploadButton = document.getElementById('upload-button');
    uploadButton.addEventListener('click', () => {
        fileInput.click();
    });

    // å°†å›¾ç‰‡æ’å…¥åˆ°å›¾ç‰‡é¢„è§ˆåˆ—è¡¨
const imagePreviewList = document.getElementById('image-preview-list'); // è·å–å›¾ç‰‡é¢„è§ˆåˆ—è¡¨å®¹å™¨

// å¤„ç†æ–‡ä»¶é€‰æ‹©
fileInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    // æ£€æŸ¥æ–‡ä»¶ç±»å‹
    if (!file.type.startsWith('image/')) {
        showError('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
        return;
    }

    // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶ä¸º10MBï¼‰
    if (file.size > 10 * 1024 * 1024) {
        showError('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡10MB');
        return;
    }

    // åˆ›å»º FormData å¯¹è±¡
    const formData = new FormData();
    formData.append('image', file);

    // æ˜¾ç¤ºä¸Šä¼ ä¸­çš„æç¤º
    const userInput = document.getElementById('user-input');
    const originalPlaceholder = userInput.placeholder;
    const uploadButton = document.getElementById('upload-button');
    uploadButton.disabled = true;

    try {
        userInput.placeholder = 'æ­£åœ¨ä¸Šä¼ å›¾ç‰‡...';
        userInput.disabled = true;

        // å‘é€ä¸Šä¼ è¯·æ±‚
        const response = await fetch('/upload_image', {
            method: 'POST',
            body: formData
        });

        const data = await response.json();

        if (!response.ok) {
            throw new Error(data.error || 'ä¸Šä¼ å¤±è´¥');
        }

        const base64Image = data.base64_image;
        const localFilePath = data.file_path;

        // åˆ›å»ºå›¾ç‰‡é¢„è§ˆé¡¹
        const imagePreviewList = document.getElementById('image-preview-list');
        const imageItem = document.createElement('div');
        imageItem.className = 'image-preview-item';

        // å›¾ç‰‡å±•ç¤º
        const imgElement = document.createElement('img');
        imgElement.src = `data:image/jpeg;base64,${base64Image}`;
        imgElement.alt = file.name;
        imgElement.className = 'preview-image';

        // å›¾ç‰‡æ–‡ä»¶å
        const fileName = document.createElement('span');
        fileName.textContent = file.name;
        fileName.className = 'image-name';

        // ä¿å­˜æ–‡ä»¶æœ¬åœ°è·¯å¾„
        imageItem.setAttribute('data-local-path', localFilePath);

        // åˆ é™¤æŒ‰é’®
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'x';
        deleteButton.className = 'delete-image';
        deleteButton.addEventListener('click', () => {
            imagePreviewList.removeChild(imageItem);
        });

        // å°†å…ƒç´ æ·»åŠ åˆ°å›¾ç‰‡é¢„è§ˆé¡¹
        imageItem.appendChild(imgElement);
        imageItem.appendChild(fileName);
        imageItem.appendChild(deleteButton);

        // æ·»åŠ å›¾ç‰‡é¢„è§ˆé¡¹åˆ°åˆ—è¡¨
        imagePreviewList.appendChild(imageItem);

    } catch (error) {
        console.error('ä¸Šä¼ å¤±è´¥:', error);
        showError(error.message || 'å›¾ç‰‡ä¸Šä¼ å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
        // æ¢å¤è¾“å…¥æ¡†å’Œä¸Šä¼ æŒ‰é’®çŠ¶æ€
        userInput.placeholder = originalPlaceholder;
        userInput.disabled = false;
        uploadButton.disabled = false;
        // æ¸…ç©ºæ–‡ä»¶è¾“å…¥ï¼Œå…è®¸é‡å¤ä¸Šä¼ ç›¸åŒæ–‡ä»¶
        fileInput.value = '';
    }
});
});

// æ·»åŠ åŠ è½½æ¨¡å‹åˆ—è¡¨çš„å‡½æ•°
async function loadModels() {
    try {
        const response = await fetch('/api/models');
        const models = await response.json();
        const select = document.getElementById('model-select');
        
        // æ¸…ç©ºç°æœ‰é€‰é¡¹
        select.innerHTML = '<option value="" disabled>é€‰æ‹©æ¨¡å‹...</option>';
        
        // æ·»åŠ xAIæ¨¡å‹ç»„
        if (models.xai && models.xai.models.length > 0) {
            const xaiGroup = document.createElement('optgroup');
            xaiGroup.label = 'xAI Models';
            models.xai.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = `${model.name} - ${model.description}`;
                xaiGroup.appendChild(option);
            });
            select.appendChild(xaiGroup);
        }
        
        // æ·»åŠ Googleæ¨¡å‹ç»„
        if (models.google && models.google.models.length > 0) {
            const googleGroup = document.createElement('optgroup');
            googleGroup.label = 'Google Models';
            models.google.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = `${model.name} - ${model.description}`;
                googleGroup.appendChild(option);
            });
            select.appendChild(googleGroup);
        }
        
        // è®¾ç½®é»˜è®¤é€‰ä¸­çš„æ¨¡å‹
        select.value = 'grok-2-vision-1212';
    } catch (error) {
        console.error('è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥:', error);
    }
}

// æ·»åŠ å¤åˆ¶ä»£ç åŠŸèƒ½
function copyCode(button) {
    const pre = button.parentElement.nextElementSibling;
    const code = pre.querySelector('code');
    const text = code.innerText;

    navigator.clipboard.writeText(text).then(() => {
        button.textContent = 'å·²å¤åˆ¶ï¼';
        button.classList.add('copied');
        
        setTimeout(() => {
            button.textContent = 'å¤åˆ¶ä»£ç ';
            button.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        console.error('å¤åˆ¶å¤±è´¥:', err);
        button.textContent = 'å¤åˆ¶å¤±è´¥';
        
        setTimeout(() => {
            button.textContent = 'å¤åˆ¶ä»£ç ';
        }, 2000);
    });
}

// ç¡®ä¿ copyCode å‡½æ•°åœ¨å…¨å±€èŒƒå›´å¯ç”¨
window.copyCode = copyCode; 

// ä¿®æ”¹é‡æ–°ç”Ÿæˆæ¶ˆæ¯çš„å‡½æ•°
async function regenerateMessage(messageIndex) {
    if (!currentConversationId) return;
    
    const currentConversation = conversations.find(c => c.id === currentConversationId);
    if (!currentConversation) return;
    
    const message = currentConversation.messages[messageIndex];
    if (!message || message.role !== 'assistant') return;
    
    // åˆå§‹åŒ–versionsæ•°ç»„(å¦‚æœä¸å­˜åœ¨)
    if (!message.versions) {
        message.versions = [message.content];
        message.currentVersion = 0;
    }
    
    // è·å–åˆ°æŒ‡å®šæ¶ˆæ¯ä¹‹å‰çš„æ‰€æœ‰æ¶ˆæ¯
    const messagesUntilIndex = currentConversation.messages.slice(0, messageIndex);
    
    // è®¾ç½®messagesæ•°ç»„ç”¨äºAPIè¯·æ±‚
    messages = [
        {"role": "system", "content": default_system_prompt},
        ...messagesUntilIndex
    ];
    
    // ç¦ç”¨å‘é€æŒ‰é’®ï¼Œæ˜¾ç¤ºåœæ­¢æŒ‰é’®
    sendButton.textContent = 'åœæ­¢';
    sendButton.classList.add('stop');
    
    try {
        // è·å–é€‰ä¸­çš„æ¨¡å‹ID
        const modelSelect = document.getElementById('model-select');
        const selectedModel = modelSelect.value;
        
        if (!selectedModel) {
            alert('è¯·é€‰æ‹©ä¸€ä¸ªæ¨¡å‹');
            return;
        }
        
        const response = await fetch('/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                messages: messages,
                conversation_id: currentConversationId,
                model_id: selectedModel
            })
        });
        
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        
        const reader = response.body.getReader();
        currentReader = reader;
        const decoder = new TextDecoder();
        
        let assistantMessage = '';
        
        // è·å–å½“å‰æ¶ˆæ¯å…ƒç´ 
        const messageDiv = chatMessages.children[messageIndex];
        const messageContent = messageDiv.querySelector('.message-content');
        
        while (true) {
            try {
                const { value, done } = await reader.read();
                if (done) break;
                
                const chunk = decoder.decode(value);
                const lines = chunk.split('\n');
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(line.slice(6));
                            if (data.error) {
                                console.error('Server error:', data.error);
                                messageContent.innerHTML = md.render('å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•');
                            } else if (data.content) {
                                assistantMessage += data.content;
                                messageContent.innerHTML = md.render(assistantMessage);
                                applyCodeHighlight(messageContent);
                                if (shouldAutoScroll(chatMessages)) {
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                }
                            }
                        } catch (e) {
                            console.error('Error parsing SSE data:', e);
                        }
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError' || error.name === 'CancelError') {
                    console.log('Stream reading cancelled');
                    break;
                }
                throw error;
            }
        }
        
        if (assistantMessage.trim()) {
            // å°†æ–°çš„å›å¤æ·»åŠ åˆ°versionsæ•°ç»„
            message.versions.push(assistantMessage);
            message.currentVersion = message.versions.length - 1;
            message.content = assistantMessage;
            
            // æ›´æ–°UIï¼Œæ·»åŠ ç‰ˆæœ¬æ§åˆ¶å’Œé‡æ–°ç”ŸæˆæŒ‰é’®
            const messageWrapper = messageDiv.querySelector('.message-wrapper');
            const messageActions = messageWrapper.querySelector('.message-actions');
            messageActions.innerHTML = ''; // æ¸…ç©ºç°æœ‰æŒ‰é’®
            
            // æ·»åŠ ç‰ˆæœ¬æ§åˆ¶
            if (message.versions.length > 1) {
                const versionControl = document.createElement('div');
                versionControl.className = 'version-control';
                
                const prevButton = document.createElement('button');
                prevButton.className = 'version-btn';
                prevButton.textContent = 'â†';
                prevButton.disabled = message.currentVersion === 0;
                prevButton.onclick = () => switchVersion(messageIndex, message.currentVersion - 1);
                
                const nextButton = document.createElement('button');
                nextButton.className = 'version-btn';
                nextButton.textContent = 'â†’';
                nextButton.disabled = message.currentVersion === message.versions.length - 1;
                nextButton.onclick = () => switchVersion(messageIndex, message.currentVersion + 1);
                
                const versionText = document.createElement('span');
                versionText.className = 'version-text';
                versionText.textContent = `ç‰ˆæœ¬ ${message.currentVersion + 1}/${message.versions.length}`;
                
                versionControl.appendChild(prevButton);
                versionControl.appendChild(versionText);
                versionControl.appendChild(nextButton);
                messageActions.appendChild(versionControl);
            }
            
            // æ·»åŠ é‡æ–°ç”ŸæˆæŒ‰é’®
            const regenerateBtn = document.createElement('button');
            regenerateBtn.className = 'regenerate-btn';
            regenerateBtn.innerHTML = 'ğŸ”„ é‡æ–°ç”Ÿæˆ';
            regenerateBtn.onclick = () => regenerateMessage(messageIndex);
            messageActions.appendChild(regenerateBtn);
            
            // ä¿å­˜å¯¹è¯
            await saveConversations();
        }
    } catch (error) {
        console.error('Error:', error);
        messageContent.innerHTML = md.render('å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•');
    } finally {
        if (currentReader) {
            try {
                await currentReader.cancel();
            } catch (e) {
                console.log('Error cancelling stream:', e);
            }
            currentReader = null;
        }
        sendButton.textContent = 'å‘é€';
        sendButton.classList.remove('stop');
        sendButton.disabled = false;
    }
}
// ä¿®æ”¹ editUserMessage å‡½æ•°
function editUserMessage(messageIndex, originalContent) {
    if (!currentConversationId) return;
    
    const currentConversation = conversations.find(c => c.id === currentConversationId);
    if (!currentConversation) return;
    
    // è·å–ç¼–è¾‘çš„æ¶ˆæ¯å…ƒç´ å’Œé™„ä»¶
    const messageDiv = chatMessages.children[messageIndex];
    if (!messageDiv) return;
    
    const originalMessage = currentConversation.messages[messageIndex];
    const originalAttachments = originalMessage.attachments || [];
    
    // åˆ›å»ºç¼–è¾‘æ¡†å®¹å™¨
    const editDiv = document.createElement('div');
    editDiv.className = 'edit-message-container';
    
    // åˆ›å»ºæ–‡æœ¬ç¼–è¾‘åŒº
    const editTextarea = document.createElement('textarea');
    editTextarea.className = 'edit-textarea';
    editTextarea.value = originalContent;
    
    // åˆ›å»ºå›¾ç‰‡é¢„è§ˆåŒº
    const imagePreviewArea = document.createElement('div');
    imagePreviewArea.className = 'edit-image-preview-list';
    
    // æ·»åŠ ç°æœ‰çš„å›¾ç‰‡
    originalAttachments.forEach(attachment => {
        if (attachment.type === 'image') {
            const imageItem = document.createElement('div');
            imageItem.className = 'image-preview-item';
            
            const img = document.createElement('img');
            img.src = `data:image/jpeg;base64,${attachment.base64}`;
            img.className = 'preview-image';
            
            const fileName = document.createElement('span');
            fileName.textContent = attachment.fileName;
            fileName.className = 'image-name';
            
            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'x';
            deleteButton.className = 'delete-image';
            deleteButton.onclick = () => imageItem.remove();
            
            imageItem.appendChild(img);
            imageItem.appendChild(fileName);
            imageItem.appendChild(deleteButton);
            imageItem.setAttribute('data-local-path', attachment.filePath);
            
            imagePreviewArea.appendChild(imageItem);
        }
    });
    
    // åˆ›å»ºä¸Šä¼ æ–°å›¾ç‰‡çš„æŒ‰é’®
    const uploadButton = document.createElement('button');
    uploadButton.className = 'upload-button';
    uploadButton.textContent = 'æ·»åŠ å›¾ç‰‡';
    uploadButton.onclick = () => {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        
        fileInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const formData = new FormData();
            formData.append('image', file);
            
            try {
                const response = await fetch('/upload_image', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) throw new Error('ä¸Šä¼ å¤±è´¥');
                
                const data = await response.json();
                
                // åˆ›å»ºæ–°çš„å›¾ç‰‡é¢„è§ˆé¡¹
                const imageItem = document.createElement('div');
                imageItem.className = 'image-preview-item';
                
                const img = document.createElement('img');
                img.src = `data:image/jpeg;base64,${data.base64_image}`;
                img.className = 'preview-image';
                
                const fileName = document.createElement('span');
                fileName.textContent = file.name;
                fileName.className = 'image-name';
                
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'x';
                deleteButton.className = 'delete-image';
                deleteButton.onclick = () => imageItem.remove();
                
                imageItem.appendChild(img);
                imageItem.appendChild(fileName);
                imageItem.appendChild(deleteButton);
                imageItem.setAttribute('data-local-path', data.file_path);
                
                imagePreviewArea.appendChild(imageItem);
            } catch (error) {
                console.error('ä¸Šä¼ å¤±è´¥:', error);
                alert('å›¾ç‰‡ä¸Šä¼ å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        };
        
        fileInput.click();
    };
    
    // åˆ›å»ºæŒ‰é’®å®¹å™¨
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'edit-buttons';
    
    const saveButton = document.createElement('button');
    saveButton.textContent = 'ä¿å­˜';
    saveButton.onclick = async () => {
        const newContent = editTextarea.value.trim();
        if (!newContent) return;
        
        // æ”¶é›†å½“å‰çš„å›¾ç‰‡é™„ä»¶
        const newAttachments = Array.from(imagePreviewArea.children).map(item => ({
            type: 'image',
            base64: item.querySelector('img').src.split(',')[1],
            fileName: item.querySelector('.image-name').textContent,
            filePath: item.getAttribute('data-local-path')
        }));
        
        // æ›´æ–°æ¶ˆæ¯å†…å®¹å’Œé™„ä»¶
        currentConversation.messages[messageIndex].content = newContent;
        currentConversation.messages[messageIndex].attachments = newAttachments;
        
        // æ›´æ–°UI
        messageDiv.style.display = 'block';
        const messageContent = messageDiv.querySelector('.message-content');
        messageContent.innerHTML = ''; // æ¸…ç©ºç°æœ‰å†…å®¹
        
        // æ·»åŠ æ–‡æœ¬å†…å®¹
        const textContent = document.createElement('div');
        textContent.className = 'text-content';
        textContent.textContent = newContent;
        messageContent.appendChild(textContent);
        
        // æ·»åŠ å›¾ç‰‡é™„ä»¶
        if (newAttachments.length > 0) {
            const attachmentsContainer = createAttachmentsContainer(newAttachments);
            if (attachmentsContainer) {
                messageContent.appendChild(attachmentsContainer);
            }
        }
        
        // ç§»é™¤ç¼–è¾‘æ¡†
        editDiv.remove();
        
        // è§¦å‘é‡æ–°ç”Ÿæˆ
        await regenerateMessage(messageIndex + 1);
    };
    
    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'å–æ¶ˆ';
    cancelButton.onclick = () => {
        messageDiv.style.display = 'block';
        editDiv.remove();
    };
    
    buttonContainer.appendChild(saveButton);
    buttonContainer.appendChild(cancelButton);
    
    // ç»„è£…ç¼–è¾‘æ¡†
    editDiv.appendChild(editTextarea);
    editDiv.appendChild(uploadButton);
    editDiv.appendChild(imagePreviewArea);
    editDiv.appendChild(buttonContainer);
    
    // éšè—åŸå§‹æ¶ˆæ¯
    messageDiv.style.display = 'none';
    
    // åœ¨åŸå§‹æ¶ˆæ¯ä¹‹åæ’å…¥ç¼–è¾‘æ¡†
    messageDiv.parentNode.insertBefore(editDiv, messageDiv.nextSibling);
    
    // è‡ªåŠ¨èšç„¦åˆ°ç¼–è¾‘æ¡†
    editTextarea.focus();
}

// æ·»åŠ åˆ‡æ¢ç‰ˆæœ¬çš„å‡½æ•°
function switchVersion(messageIndex, newVersion) {
    const currentConversation = conversations.find(c => c.id === currentConversationId);
    if (!currentConversation) return;
    
    const message = currentConversation.messages[messageIndex];
    if (!message || !message.versions || !message.versions[newVersion]) return;
    
    // æ›´æ–°å½“å‰ç‰ˆæœ¬
    message.currentVersion = newVersion;
    message.content = message.versions[newVersion];
    
    // æ›´æ–°UI
    const messageDiv = chatMessages.children[messageIndex];
    const messageContent = messageDiv.querySelector('.message-content');
    messageContent.innerHTML = md.render(message.content);
    applyCodeHighlight(messageContent);
    
    // æ›´æ–°ç‰ˆæœ¬æ§åˆ¶æŒ‰é’®çŠ¶æ€
    const messageActions = messageDiv.querySelector('.message-actions');
    if (messageActions) {
        // æ¸…ç©ºç°æœ‰çš„æ“ä½œæŒ‰é’®
        messageActions.innerHTML = '';
        
        // é‡æ–°æ·»åŠ é‡æ–°ç”ŸæˆæŒ‰é’®
        const regenerateBtn = document.createElement('button');
        regenerateBtn.className = 'regenerate-btn';
        regenerateBtn.innerHTML = 'ğŸ”„ é‡æ–°ç”Ÿæˆ';
        regenerateBtn.onclick = () => regenerateMessage(messageIndex);
        messageActions.appendChild(regenerateBtn);
        
        // é‡æ–°æ·»åŠ ç‰ˆæœ¬æ§åˆ¶
        if (message.versions.length > 1) {
            const versionControl = document.createElement('div');
            versionControl.className = 'version-control';
            
            const prevButton = document.createElement('button');
            prevButton.className = 'version-btn';
            prevButton.textContent = 'â†';
            prevButton.disabled = newVersion === 0;
            prevButton.onclick = () => switchVersion(messageIndex, newVersion - 1);
            
            const nextButton = document.createElement('button');
            nextButton.className = 'version-btn';
            nextButton.textContent = 'â†’';
            nextButton.disabled = newVersion === message.versions.length - 1;
            nextButton.onclick = () => switchVersion(messageIndex, newVersion + 1);
            
            const versionText = document.createElement('span');
            versionText.className = 'version-text';
            versionText.textContent = `ç‰ˆæœ¬ ${newVersion + 1}/${message.versions.length}`;
            
            versionControl.appendChild(prevButton);
            versionControl.appendChild(versionText);
            versionControl.appendChild(nextButton);
            messageActions.appendChild(versionControl);
        }
    }
    
    saveConversations();
}

//ç”¨äºå‰ªè´´æ¿ç²˜è´´å›¾ç‰‡ç›‘å¬
document.addEventListener('DOMContentLoaded', async () => {
    // ... ç°æœ‰çš„åˆå§‹åŒ–ä»£ç  ...

    // æ·»åŠ å‰ªè´´æ¿ç²˜è´´äº‹ä»¶ç›‘å¬
    userInput.addEventListener('paste', async (e) => {
        // é˜»æ­¢é»˜è®¤ç²˜è´´è¡Œä¸º
        e.preventDefault();

        // è·å–å‰ªè´´æ¿æ•°æ®
        const clipboardData = e.clipboardData;
        const items = clipboardData.items;

        let hasImage = false;
        let hasText = false;

        // éå†å‰ªè´´æ¿æ•°æ®
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            
            if (item.type.indexOf('image') !== -1) {
                hasImage = true;
                const file = item.getAsFile();
                
                // æ£€æŸ¥æ–‡ä»¶å¤§å°
                if (file.size > 10 * 1024 * 1024) {
                    showError('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡10MB');
                    continue;
                }

                // åˆ›å»º FormData å¯¹è±¡
                const formData = new FormData();
                formData.append('image', file);

                try {
                    const response = await fetch('/upload_image', {
                        method: 'POST',
                        body: formData
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'ä¸Šä¼ å¤±è´¥');
                    }

                    // è·å–å›¾ç‰‡é¢„è§ˆåˆ—è¡¨
                    const imagePreviewList = document.getElementById('image-preview-list');
                    
                    // åˆ›å»ºå›¾ç‰‡é¢„è§ˆé¡¹
                    const imageItem = document.createElement('div');
                    imageItem.className = 'image-preview-item';
                    
                    // å›¾ç‰‡å±•ç¤º
                    const imgElement = document.createElement('img');
                    imgElement.src = `data:image/jpeg;base64,${data.base64_image}`;
                    imgElement.alt = 'ç²˜è´´çš„å›¾ç‰‡';
                    imgElement.className = 'preview-image';
                    
                    // å›¾ç‰‡æ–‡ä»¶å
                    const fileName = document.createElement('span');
                    fileName.textContent = `ç²˜è´´çš„å›¾ç‰‡_${Date.now()}.png`;
                    fileName.className = 'image-name';
                    
                    // ä¿å­˜æ–‡ä»¶æœ¬åœ°è·¯å¾„
                    imageItem.setAttribute('data-local-path', data.file_path);
                    
                    // åˆ é™¤æŒ‰é’®
                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = 'x';
                    deleteButton.className = 'delete-image';
                    deleteButton.addEventListener('click', () => {
                        imagePreviewList.removeChild(imageItem);
                    });
                    
                    // å°†å…ƒç´ æ·»åŠ åˆ°å›¾ç‰‡é¢„è§ˆé¡¹
                    imageItem.appendChild(imgElement);
                    imageItem.appendChild(fileName);
                    imageItem.appendChild(deleteButton);
                    
                    // æ·»åŠ å›¾ç‰‡é¢„è§ˆé¡¹åˆ°åˆ—è¡¨
                    imagePreviewList.appendChild(imageItem);

                } catch (error) {
                    console.error('ä¸Šä¼ å¤±è´¥:', error);
                    showError(error.message || 'å›¾ç‰‡ä¸Šä¼ å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            } else if (item.type === 'text/plain') {
                hasText = true;
                item.getAsString(text => {
                    const start = userInput.selectionStart;
                    const end = userInput.selectionEnd;
                    const value = userInput.value;
                    userInput.value = value.substring(0, start) + text + value.substring(end);
                    userInput.selectionStart = userInput.selectionEnd = start + text.length;
                });
            }
        }

        // å¦‚æœæ—¢æ²¡æœ‰å›¾ç‰‡ä¹Ÿæ²¡æœ‰æ–‡æœ¬ï¼Œæ˜¾ç¤ºæç¤º
        if (!hasImage && !hasText) {
            showError('å‰ªè´´æ¿ä¸­æ²¡æœ‰å¯ç”¨çš„å†…å®¹');
        }
    });
});

document.addEventListener('DOMContentLoaded', () => {
    const header = document.getElementById('system-prompt-header');
    const textarea = document.getElementById('system-prompt');
    const toggleButton = header.querySelector('.toggle-button');
    
    // å¦‚æœ textarea æ˜¯ç©ºçš„ï¼Œå¡«å……é»˜è®¤æç¤ºè¯
    if (!textarea.value.trim()) {
        textarea.value = default_system_prompt;
    }

    // åˆå§‹çŠ¶æ€è®¾ç½®ä¸ºæ”¶èµ·
    textarea.classList.add('collapsed');
    
    const togglePrompt = (e) => {
        if (e.target === textarea) {
            return;
        }
        
        textarea.classList.toggle('collapsed');
        toggleButton.classList.toggle('rotated');
        
        if (!textarea.classList.contains('collapsed')) {
            textarea.style.height = 'auto';
            const height = Math.min(textarea.scrollHeight, 200);
            textarea.style.height = height + 'px';
        } else {
            textarea.style.height = '0';
        }
    };

    header.addEventListener('click', togglePrompt);
    
    // æ–‡æœ¬æ¡†çš„é«˜åº¦è‡ªé€‚åº”
    textarea.addEventListener('input', () => {
        if (!textarea.classList.contains('collapsed')) {
            textarea.style.height = 'auto';
            const height = Math.min(textarea.scrollHeight, 200);
            textarea.style.height = height + 'px';
        }
    });
});

// æ·»åŠ ç³»ç»Ÿæç¤ºè¯å˜æ›´ç›‘å¬
document.addEventListener('DOMContentLoaded', () => {
    // ... ç°æœ‰çš„ DOMContentLoaded ä»£ç  ...

    // æ·»åŠ ç³»ç»Ÿæç¤ºè¯å˜æ›´äº‹ä»¶ç›‘å¬
    const systemPromptTextarea = document.getElementById('system-prompt');
    let saveTimeout;
    
    systemPromptTextarea.addEventListener('input', () => {
        // ä½¿ç”¨é˜²æŠ–å¤„ç†ï¼Œé¿å…é¢‘ç¹ä¿å­˜
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(async () => {
            if (currentConversationId) {
                const currentConversation = conversations.find(c => c.id === currentConversationId);
                if (currentConversation) {
                    currentConversation.systemPrompt = systemPromptTextarea.value; // æ›´æ–°ç³»ç»Ÿæç¤ºè¯
                    messages[0] = {"role": "system", "content": currentConversation.systemPrompt || default_system_prompt}; // åªåœ¨å‘é€æ¶ˆæ¯æ—¶ä½¿ç”¨é»˜è®¤æç¤ºè¯
                    await saveConversations();
                }
            }
        }, 1000); // 1ç§’åä¿å­˜
    });
});

// åœ¨æ–‡ä»¶å¼€å¤´æ·»åŠ è¿™ä¸ªå‡½æ•°
function showError(message) {
    const toast = document.createElement('div');
    toast.className = 'toast error';
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 3000);
}

// æ·»åŠ ç”Ÿæˆæ ‡é¢˜çš„å‡½æ•°
async function generateTitle(firstMessage) {
    try {
        const response = await fetch('/generate_title', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                message: firstMessage,
                model_id: 'gemini-1.5-flash-8b'
            })
        });

        if (!response.ok) throw new Error('ç”Ÿæˆæ ‡é¢˜å¤±è´¥');

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let title = '';
        const conversationItem = document.querySelector(`.conversation-item[data-id="${currentConversationId}"]`);
        const titleElement = conversationItem?.querySelector('.conversation-title');

        while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));
                        if (data.content) {
                            title += data.content;
                            if (titleElement) {
                                titleElement.textContent = title;
                            }
                        }
                    } catch (e) {
                        console.error('Error parsing title SSE data:', e);
                    }
                }
            }
        }

        // æ›´æ–°å¯¹è¯æ ‡é¢˜
        if (title.trim()) {
            const currentConversation = conversations.find(c => c.id === currentConversationId);
            if (currentConversation) {
                currentConversation.title = title.trim();
                await saveConversations();
            }
        }

    } catch (error) {
        console.error('ç”Ÿæˆæ ‡é¢˜å¤±è´¥:', error);
    }
}

// æ·»åŠ ç¼–è¾‘å¯¹è¯æ ‡é¢˜çš„å‡½æ•°
function editConversationTitle(conversationId) {
    const conversationItem = document.querySelector(`.conversation-item[data-id="${conversationId}"]`);
    const titleContainer = conversationItem.querySelector('.conversation-title-container');
    const titleElement = titleContainer.querySelector('.conversation-title');
    const currentTitle = titleElement.textContent;
    
    // åˆ›å»ºè¾“å…¥æ¡†
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'edit-title-input';
    input.value = currentTitle;
    
    // æ›¿æ¢æ ‡é¢˜å…ƒç´ 
    titleContainer.replaceChild(input, titleElement);
    input.focus();
    input.select();
    
    // å¤„ç†ä¿å­˜
    const saveTitle = async () => {
        const newTitle = input.value.trim();
        if (newTitle && newTitle !== currentTitle) {
            const conversation = conversations.find(c => c.id === conversationId);
            if (conversation) {
                conversation.title = newTitle;
                await saveConversations();
            }
        }
        titleElement.textContent = newTitle || currentTitle;
        titleContainer.replaceChild(titleElement, input);
    };
    
    // ç›‘å¬äº‹ä»¶
    input.onblur = saveTitle;
    input.onkeydown = (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            saveTitle();
        } else if (e.key === 'Escape') {
            titleElement.textContent = currentTitle;
            titleContainer.replaceChild(titleElement, input);
        }
    };
}

